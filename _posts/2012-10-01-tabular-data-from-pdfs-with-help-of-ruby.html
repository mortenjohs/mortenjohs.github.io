---
layout: post
title: Tabular data from PDFs with the help of Ruby
date: '2012-10-01T22:27:00.000+02:00'
author: Morten
tags:
- Programming
- hack
- gist
- source code
- Ruby
modified_time: '2014-12-10T14:14:35.091+01:00'
blogger_id: tag:blogger.com,1999:blog-6967032375013519080.post-6836297893627423750
blogger_orig_url: https://m635j520.blogspot.com/2012/10/tabular-data-from-pdfs-with-help-of-ruby.html
---

Sometimes I need to get data out of tables buried in PDFs, so&nbsp;I've written a tiny adaptable Ruby hack for when copying and pasting doesn't cut it - exploiting a couple of excellent libraries. Here's an example.<br /><div class="gistLoad" data-id="3806618" id="gist-3806618">Loading...</div><br />(Admittedly not the most elegant of scripts, but hey! it gets the job done.)<br /><br />What I do first here is just load up the relevant libraries. (The pdf-reader I use is this one: <a href="https://github.com/yob/pdf-reader" target="_blank">https://github.com/yob/pdf-reader</a>  - installable with a simple command line 'sudo gem install pdf-reader'&nbsp;if you are using Ruby 1.9. (Drop the sudo if you're on Windows.))<br /><br />Next up is to instantiate input pdf and output table. Straight forward enough.<br /><br />By examining the pdf I found the data I was interested in on pages 42 through 69, so a simple call to pages give me those -&nbsp;<span class="n" style="background-color: ghostwhite; font-family: 'Bitstream Vera Sans Mono', Courier, monospace; font-size: 14px; line-height: 19px; text-align: justify; white-space: pre;">pdf_reader</span><span class="o" style="background-color: ghostwhite; font-family: 'Bitstream Vera Sans Mono', Courier, monospace; font-size: 14px; font-weight: bold; line-height: 19px; text-align: justify; white-space: pre;">.</span><span class="n" style="background-color: ghostwhite; font-family: 'Bitstream Vera Sans Mono', Courier, monospace; font-size: 14px; line-height: 19px; text-align: justify; white-space: pre;">pages</span><span class="o" style="background-color: ghostwhite; font-family: 'Bitstream Vera Sans Mono', Courier, monospace; font-size: 14px; font-weight: bold; line-height: 19px; text-align: justify; white-space: pre;">[</span><span class="o" style="background-color: ghostwhite; color: #009999; font-family: 'Bitstream Vera Sans Mono', Courier, monospace; font-size: 14px; line-height: 19px; text-align: justify; white-space: pre;">42</span><span class="o" style="background-color: ghostwhite; font-family: 'Bitstream Vera Sans Mono', Courier, monospace; font-size: 14px; font-weight: bold; line-height: 19px; text-align: justify; white-space: pre;">.</span><span class="n" style="background-color: ghostwhite; font-family: 'Bitstream Vera Sans Mono', Courier, monospace; font-size: 14px; line-height: 19px; text-align: justify; white-space: pre;">.</span><span class="mi" style="background-color: ghostwhite; color: #009999; font-family: 'Bitstream Vera Sans Mono', Courier, monospace; font-size: 14px; line-height: 19px; text-align: justify; white-space: pre;">69</span><span class="o" style="background-color: ghostwhite; font-family: 'Bitstream Vera Sans Mono', Courier, monospace; font-size: 14px; font-weight: bold; line-height: 19px; text-align: justify; white-space: pre;">]</span>. I'll go through the text on each of them line by line and decide if they contain what I want based on regular expressions. These are my simple rules (in this example):<br /><ol><li>If a line contains only letters, ie&nbsp;<span style="background-color: ghostwhite; color: #009926; font-family: 'Bitstream Vera Sans Mono', Courier, monospace; font-size: 14px; line-height: 19px; text-align: justify; white-space: pre;">/^[a-z|\s]*$/i </span>&nbsp;(the regular expression is non-case sensitive due to the added 'i') and whitespaces - it means, in this case, that it is a geographic location, and I update the current area variable.</li><li>If not, I try to read the line as a data line. A data line in my case looks something like this:<br /><span style="font-family: Courier New, Courier, monospace;">Country Name12.3(10.0-15.0)12.3(10.0-15.0)12.3(10.0-15.0)12.3(10.0-15.0)</span><br />To get the country name I split the line at the first digit with a&nbsp;<span class="n" style="background-color: ghostwhite; font-family: 'Bitstream Vera Sans Mono', Courier, monospace; font-size: 14px; line-height: 19px; text-align: justify; white-space: pre;">line</span><span class="o" style="background-color: ghostwhite; font-family: 'Bitstream Vera Sans Mono', Courier, monospace; font-size: 14px; font-weight: bold; line-height: 19px; text-align: justify; white-space: pre;">.</span><span class="n" style="background-color: ghostwhite; font-family: 'Bitstream Vera Sans Mono', Courier, monospace; font-size: 14px; line-height: 19px; text-align: justify; white-space: pre;">split</span><span class="p" style="background-color: ghostwhite; font-family: 'Bitstream Vera Sans Mono', Courier, monospace; font-size: 14px; line-height: 19px; text-align: justify; white-space: pre;">(</span><span class="sr" style="background-color: ghostwhite; color: #009926; font-family: 'Bitstream Vera Sans Mono', Courier, monospace; font-size: 14px; line-height: 19px; text-align: justify; white-space: pre;">/[0-9]/</span><span class="p" style="background-color: ghostwhite; font-family: 'Bitstream Vera Sans Mono', Courier, monospace; font-size: 14px; line-height: 19px; text-align: justify; white-space: pre;">)</span>&nbsp;and take the first element in the result with&nbsp;<span class="n" style="background-color: ghostwhite; font-family: 'Bitstream Vera Sans Mono', Courier, monospace; font-size: 14px; line-height: 19px; text-align: justify; white-space: pre;">first</span>. I remove this element from the line (<span class="n" style="background-color: ghostwhite; font-family: 'Bitstream Vera Sans Mono', Courier, monospace; font-size: 14px; line-height: 19px; text-align: justify; white-space: pre;">line</span><span class="o" style="background-color: ghostwhite; font-family: 'Bitstream Vera Sans Mono', Courier, monospace; font-size: 14px; font-weight: bold; line-height: 19px; text-align: justify; white-space: pre;">.</span><span class="n" style="background-color: ghostwhite; font-family: 'Bitstream Vera Sans Mono', Courier, monospace; font-size: 14px; line-height: 19px; text-align: justify; white-space: pre;">sub</span><span class="p" style="background-color: ghostwhite; font-family: 'Bitstream Vera Sans Mono', Courier, monospace; font-size: 14px; line-height: 19px; text-align: justify; white-space: pre;">(</span><span class="n" style="background-color: ghostwhite; font-family: 'Bitstream Vera Sans Mono', Courier, monospace; font-size: 14px; line-height: 19px; text-align: justify; white-space: pre;">country</span><span class="p" style="background-color: ghostwhite; font-family: 'Bitstream Vera Sans Mono', Courier, monospace; font-size: 14px; line-height: 19px; text-align: justify; white-space: pre;">,</span><span class="s1" style="background-color: ghostwhite; color: #dd1144; font-family: 'Bitstream Vera Sans Mono', Courier, monospace; font-size: 14px; line-height: 19px; text-align: justify; white-space: pre;">''</span><span class="p" style="background-color: ghostwhite; font-family: 'Bitstream Vera Sans Mono', Courier, monospace; font-size: 14px; line-height: 19px; text-align: justify; white-space: pre;">)</span>) so that my data line now looks like this:<br /><span style="font-family: 'Courier New', Courier, monospace;">12.3(10.0-15.0)12.3(10.0-15.0)12.3(10.0-15.0)12.3(10.0-15.0)</span><br />This is easy to split into the values and the confidence intervals with a&nbsp;<span class="n" style="background-color: ghostwhite; font-family: 'Bitstream Vera Sans Mono', Courier, monospace; font-size: 14px; line-height: 19px; text-align: justify; white-space: pre;">split</span><span class="p" style="background-color: ghostwhite; font-family: 'Bitstream Vera Sans Mono', Courier, monospace; font-size: 14px; line-height: 19px; text-align: justify; white-space: pre;">(</span><span class="sr" style="background-color: ghostwhite; color: #009926; font-family: 'Bitstream Vera Sans Mono', Courier, monospace; font-size: 14px; line-height: 19px; text-align: justify; white-space: pre;">/[\(|\)]/</span><span class="p" style="background-color: ghostwhite; font-family: 'Bitstream Vera Sans Mono', Courier, monospace; font-size: 14px; line-height: 19px; text-align: justify; white-space: pre;">)</span>&nbsp;- that simply splits on either opening or closing parenthesis. Since I want to keep all the data I just prepend the area and country name &nbsp;to the resulting array with an&nbsp;<span class="n" style="background-color: ghostwhite; font-family: 'Bitstream Vera Sans Mono', Courier, monospace; font-size: 14px; line-height: 19px; text-align: justify; white-space: pre;">unshift</span><span class="p" style="background-color: ghostwhite; font-family: 'Bitstream Vera Sans Mono', Courier, monospace; font-size: 14px; line-height: 19px; text-align: justify; white-space: pre;">(</span><span class="n" style="background-color: ghostwhite; font-family: 'Bitstream Vera Sans Mono', Courier, monospace; font-size: 14px; line-height: 19px; text-align: justify; white-space: pre;">country).unshift(area</span><span class="p" style="background-color: ghostwhite; font-family: 'Bitstream Vera Sans Mono', Courier, monospace; font-size: 14px; line-height: 19px; text-align: justify; white-space: pre;">)</span>&nbsp;before writing the line to the output file.</li></ol><div>Voila! - suddenly I have lots and lots of data in a format that can be manipulated and played around with.&nbsp;Next time I'll need data out of a PDF I'll just change the rules above in 1 and 2 depending on the formatting used.</div><div><br /></div><div>(PS: This code will not work on Ruby 1.8 unless you install the faster-csv gem - and even then I'm not sure...)</div><div><br /></div><script src="https://cdn.rawgit.com/moski/gist-Blogger/master/public/gistLoader.js" type="text/javascript"></script>