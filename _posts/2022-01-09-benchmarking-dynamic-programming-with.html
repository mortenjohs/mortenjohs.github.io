---
layout: post
title: Benchmarking Dynamic Programming with Python
date: '2022-01-09T21:55:00.056+01:00'
author: Morten
tags:
- Programming
- Optimisation
- Python
- source code
- algorithm
- Jupiter Notebook
modified_time: '2022-01-09T22:17:23.608+01:00'
thumbnail: https://lh3.googleusercontent.com/-Pb8CSa_-_BA/YdtMvXGnW_I/AAAAAAADz0g/7Tj6i6ttq3Ar6ya17yqMQ4FPim5rlQY4wCNcBGAsYHQ/s72-w640-c-h70/Screenshot%2B2022-01-09%2Bat%2B10.46.38.png
blogger_id: tag:blogger.com,1999:blog-6967032375013519080.post-242457983478061363
blogger_orig_url: https://m635j520.blogspot.com/2022/01/benchmarking-dynamic-programming-with.html
---

<div style="text-align: left;">In this post I'll explore and benchmark some simple dynamic programming concepts in Python.</div><div><br /></div><div>The example I'll use is a classic recursive implementation of the <a href="https://en.wikipedia.org/wiki/Fibonacci_number" target="_blank">fibonacci series</a>. (And for simplicity I'll skip the first element in the series (fib(0)=0).)</div><div><br /></div><a data-flickr-embed="true" href="https://www.flickr.com/photos/mortenjohs/5378706956/" title="_DSC7544.jpg"><img alt="_DSC7544.jpg" height="425" src="https://live.staticflickr.com/5121/5378706956_9fa07f7e2b_z.jpg" width="640" /></a><script async="" charset="utf-8" src="//embedr.flickr.com/assets/client-code.js"></script><h2 style="text-align: left;">Naive approach&nbsp;</h2><div>This implementation:</div><div><div class="separator" style="clear: both; text-align: center;"><a href="https://lh3.googleusercontent.com/-Pb8CSa_-_BA/YdtMvXGnW_I/AAAAAAADz0g/7Tj6i6ttq3Ar6ya17yqMQ4FPim5rlQY4wCNcBGAsYHQ/Screenshot%2B2022-01-09%2Bat%2B10.46.38.png" style="margin-left: 1em; margin-right: 1em;"><img alt="" data-original-height="216" data-original-width="1982" height="70" src="https://lh3.googleusercontent.com/-Pb8CSa_-_BA/YdtMvXGnW_I/AAAAAAADz0g/7Tj6i6ttq3Ar6ya17yqMQ4FPim5rlQY4wCNcBGAsYHQ/w640-h70/Screenshot%2B2022-01-09%2Bat%2B10.46.38.png" width="640" /></a></div></div><p>...works well (enough) for small numbers:</p><p></p><div class="separator" style="clear: both; text-align: center;"><a href="https://lh3.googleusercontent.com/-M9iwzZWQI88/YdtM1PSVfKI/AAAAAAADz0k/IRAoAqoN66koCsIUq8SvJ0puKOztQ_cOQCNcBGAsYHQ/Screenshot%2B2022-01-09%2Bat%2B10.47.55.png" style="margin-left: 1em; margin-right: 1em;"><img alt="" data-original-height="150" data-original-width="1980" height="48" src="https://lh3.googleusercontent.com/-M9iwzZWQI88/YdtM1PSVfKI/AAAAAAADz0k/IRAoAqoN66koCsIUq8SvJ0puKOztQ_cOQCNcBGAsYHQ/w640-h48/Screenshot%2B2022-01-09%2Bat%2B10.47.55.png" width="640" /></a></div><p>but becomes impossibly slow quickly...</p><p></p><div class="separator" style="clear: both; text-align: center;"><a href="https://lh3.googleusercontent.com/-mdeHWjxl-kw/YdtM8q7EBvI/AAAAAAADz0o/Af7JhdkJv2orT44sjM-YWQuzeT-OODOfQCNcBGAsYHQ/Screenshot%2B2022-01-09%2Bat%2B10.48.35.png" style="margin-left: 1em; margin-right: 1em;"><img alt="" data-original-height="160" data-original-width="1980" height="52" src="https://lh3.googleusercontent.com/-mdeHWjxl-kw/YdtM8q7EBvI/AAAAAAADz0o/Af7JhdkJv2orT44sjM-YWQuzeT-OODOfQCNcBGAsYHQ/w640-h52/Screenshot%2B2022-01-09%2Bat%2B10.48.35.png" width="640" /></a></div><p>...since it has a time complexity of O(2<span face="arial, sans-serif" style="caret-color: rgb(77, 81, 86); position: relative; top: -0.4em; vertical-align: baseline;"><span style="color: #5f6368;">n</span></span>). (So our seemingly harmless fib(42) would result in more than 4 trillion calls to fib... (Or about 4 times the number of bacteria on the human body... Or 2 times the number of galaxies in the observable universe... Or more than the estimated population of fish in the ocean... Etc.))</p><h2 style="text-align: left;">Enter dynamic programming</h2><div>Since the result of these recursive calls to fib are all deterministic, we can cache the results instead of recalculating them.</div><h3 style="text-align: left;">@functools.cache</h3><div>First a test by simply leveraging the cache in the library <a href="https://docs.python.org/3/library/functools.html">functools</a>...</div><div><div class="separator" style="clear: both; text-align: center;"><a href="https://lh3.googleusercontent.com/-4hlYrIxPUL8/YdtNMXbwOkI/AAAAAAADz04/7SeWFWcKGxMpBSanTpsElGKp8X5O2T2mACNcBGAsYHQ/Screenshot%2B2022-01-09%2Bat%2B11.38.40.png" style="margin-left: 1em; margin-right: 1em;"><img alt="" data-original-height="328" data-original-width="1976" height="106" src="https://lh3.googleusercontent.com/-4hlYrIxPUL8/YdtNMXbwOkI/AAAAAAADz04/7SeWFWcKGxMpBSanTpsElGKp8X5O2T2mACNcBGAsYHQ/w640-h106/Screenshot%2B2022-01-09%2Bat%2B11.38.40.png" width="640" /></a></div></div><div><br /></div><div>This speeds, as expected, the runtime up significantly...</div><div><div class="separator" style="clear: both; text-align: center;"><a href="https://lh3.googleusercontent.com/-EZYD6B95m3I/YdtNZZoQXCI/AAAAAAADz08/tdIjJUErBfA6taD13pQHoRULj3uz4DPLACNcBGAsYHQ/Screenshot%2B2022-01-09%2Bat%2B21.23.56.png" style="margin-left: 1em; margin-right: 1em;"><img alt="" data-original-height="154" data-original-width="1980" height="50" src="https://lh3.googleusercontent.com/-EZYD6B95m3I/YdtNZZoQXCI/AAAAAAADz08/tdIjJUErBfA6taD13pQHoRULj3uz4DPLACNcBGAsYHQ/w640-h50/Screenshot%2B2022-01-09%2Bat%2B21.23.56.png" width="640" /></a></div></div><div><br /></div><div>...by a factor of about a million in the case of this 43rd fibonacci number.</div><div><br /></div><div>(Of course we can't run timeit in loops, as the first run would generate the cache for successive runs...)</div><h3 style="text-align: left;">Hand made</h3><div>Then we can to compare this to the classic, hand made, way to implement memoization in dynamic programming, like so:</div><div><div class="separator" style="clear: both; text-align: center;"><a href="https://lh3.googleusercontent.com/-TXJUHmmcjlM/YdtNiWzMtJI/AAAAAAADz1E/tOWj-svimA0Bytf7jGaeUAxL5UuEPuMeQCNcBGAsYHQ/Screenshot%2B2022-01-09%2Bat%2B10.54.27.png" style="clear: left; float: left; margin-bottom: 1em; margin-right: 1em;"></a><a href="https://lh3.googleusercontent.com/-TXJUHmmcjlM/YdtNiWzMtJI/AAAAAAADz1E/tOWj-svimA0Bytf7jGaeUAxL5UuEPuMeQCNcBGAsYHQ/Screenshot%2B2022-01-09%2Bat%2B10.54.27.png" style="clear: left; display: inline !important; margin-bottom: 1em; margin-right: 1em;"><img alt="" data-original-height="318" data-original-width="1980" height="102" src="https://lh3.googleusercontent.com/-TXJUHmmcjlM/YdtNiWzMtJI/AAAAAAADz1E/tOWj-svimA0Bytf7jGaeUAxL5UuEPuMeQCNcBGAsYHQ/w640-h102/Screenshot%2B2022-01-09%2Bat%2B10.54.27.png" width="640" /></a></div></div><div><br /></div><div>This <i>should </i>give more or less the same results as above. And it does.&nbsp;</div><div><div class="separator" style="clear: both; text-align: center;"><a href="https://lh3.googleusercontent.com/-yaq2tS4jPsQ/YdtNu0fhEzI/AAAAAAADz1M/WITs0wr1xC8oP-cCa_vfKKWCJ6XPuF61ACNcBGAsYHQ/Screenshot%2B2022-01-09%2Bat%2B10.55.37.png" style="margin-left: 1em; margin-right: 1em;"><img alt="" data-original-height="152" data-original-width="1976" height="50" src="https://lh3.googleusercontent.com/-yaq2tS4jPsQ/YdtNu0fhEzI/AAAAAAADz1M/WITs0wr1xC8oP-cCa_vfKKWCJ6XPuF61ACNcBGAsYHQ/w640-h50/Screenshot%2B2022-01-09%2Bat%2B10.55.37.png" width="640" /></a></div></div><div><br /></div><div>Interestingly, it actually systematically<i>&nbsp;</i>outperforms the functools@cache&nbsp;<i>slightly</i>&nbsp;on my M1 air.</div><div><br /></div><div>On my intel desktop I get similar difference in results results:</div><div><br /></div><div><div class="separator" style="clear: both; text-align: center;"><a href="https://lh3.googleusercontent.com/-1uqfk_-BQxk/YdtN8xH_YLI/AAAAAAADz1U/-yqbls4450kRK6iNXF9PqDELLKuVok3qwCNcBGAsYHQ/Screenshot%2B2022-01-09%2Bat%2B11.21.25.png" style="margin-left: 1em; margin-right: 1em;"><img alt="" data-original-height="156" data-original-width="1976" height="50" src="https://lh3.googleusercontent.com/-1uqfk_-BQxk/YdtN8xH_YLI/AAAAAAADz1U/-yqbls4450kRK6iNXF9PqDELLKuVok3qwCNcBGAsYHQ/w640-h50/Screenshot%2B2022-01-09%2Bat%2B11.21.25.png" width="640" /></a></div><div class="separator" style="clear: both; text-align: left;"><a href="https://lh3.googleusercontent.com/-oCnUDGvYjtk/YdtN_kaAvjI/AAAAAAADz1c/aba-uFO9jEg2i0XfG6UoAaewFGWIsS0WwCNcBGAsYHQ/Screenshot%2B2022-01-09%2Bat%2B11.22.10.png" style="margin-left: 1em; margin-right: 1em;"><img alt="" data-original-height="158" data-original-width="1980" height="52" src="https://lh3.googleusercontent.com/-oCnUDGvYjtk/YdtN_kaAvjI/AAAAAAADz1c/aba-uFO9jEg2i0XfG6UoAaewFGWIsS0WwCNcBGAsYHQ/w640-h52/Screenshot%2B2022-01-09%2Bat%2B11.22.10.png" width="640" /></a></div></div><h2 style="text-align: left;">Conclusion</h2><div>Leveraging<b> @functools.cache</b> is a great way to implement dynamic programming memoization in Python with little code overhead (but you still <i>might</i> be able to tailor make a faster solution).<br /></div>