---
layout: post
title: Metaballs Revisited
date: '2021-11-07T21:58:00.007+01:00'
author: Morten
tags:
- Programming
- simulations
- Python
- source code
- algorithm
- visualization
modified_time: '2021-11-07T22:06:30.809+01:00'
thumbnail: https://lh3.googleusercontent.com/-cGqLzCiO7I0/YYg-_ciBDpI/AAAAAAADxEk/JB0bz86yNFoompU1v0PLaLDzhGewUoLRwCLcBGAsYHQ/s72-c/out_512x512_5681102.gif
blogger_id: tag:blogger.com,1999:blog-6967032375013519080.post-4842752155096363061
blogger_orig_url: https://m635j520.blogspot.com/2021/11/metaballs-revisited.html
---

<p>The new visual identity of my work place (and the re-ignition of an old lava lamp) made me think of the good old metaballs from the Amiga demo-scene of yonder and how it has been a while since I have implemented them from scratch. This time I wanted to play around with Python and numpy to see what that could bring.</p><p>But first, what are metaballs?&nbsp;</p><p>It's, for example, this:<br /></p><p></p><div class="separator" style="clear: both; text-align: center;"><a href="https://lh3.googleusercontent.com/-cGqLzCiO7I0/YYg-_ciBDpI/AAAAAAADxEk/JB0bz86yNFoompU1v0PLaLDzhGewUoLRwCLcBGAsYHQ/out_512x512_5681102.gif" style="margin-left: 1em; margin-right: 1em;"><img data-original-height="512" data-original-width="512" src="https://lh3.googleusercontent.com/-cGqLzCiO7I0/YYg-_ciBDpI/AAAAAAADxEk/JB0bz86yNFoompU1v0PLaLDzhGewUoLRwCLcBGAsYHQ/s16000/out_512x512_5681102.gif" /></a></div><p></p><p></p><p><br /></p><p>Wikipedia defines them as:</p><p></p><blockquote>In computer graphics, metaballs are organic-looking n-dimensional isosurfaces, characterised by their ability to meld together when in close proximity to create single, contiguous objects. <a href="https://en.wikipedia.org/wiki/Metaballs)[https://en.wikipedia.org/wiki/Metaballs">https://en.wikipedia.org/wiki/Metaballs</a></blockquote><p>As cool as multidimensional metaballs  are, we'll stick to 2D ones in this post.<br /></p><p></p><h2 id="the-algorithm">The algorithm</h2><p>The algorithm behind them is quite straightforward -- in their simplest form. Basically for each pixel in each frame, or buffer, you add up the <i>influence</i> of each metaball in the simulation and then cut off below a certain threshold and normalize what’s left. The influence function can be a simple “ball-power” over euclidean distance calculation. <br /></p> <p>So, for each pixel you get:</p><div class="highlight"><pre><span class="k">def</span> <span class="nf">generate_buffer_raw</span><span class="p">(</span><span class="n">buff</span><span class="p">,</span> <span class="n">balls</span><span class="p">):</span><br />    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n"> buff</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span><br />        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">, </span><span class="n">buff</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span><br />            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">balls</span><span class="p">:</span><br />                <span class="n">d</span> <span class="o">=</span> <span class="n">dist</span><span class="p">([</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">], </span><span class="n">b</span><span class="o">.</span><span class="n">pos</span><span class="p">)</span><br />                <span class="k">if</span> <span class="n">d</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <br />                    <span class="n">d</span> <span class="o">=</span> <span class="mi">1</span> # not correct, per se, but, alas, it works... <br />                <span class="n">effect</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">rad</span><span class="o"> / </span><span class="n">d</span><br />                <span class="n">buff</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">]</span> <span class="o">+=</span> <span class="n">effect</span><br />    <span class="k">return</span> <span class="n">buff</span><br /></pre></div> <p>And then you can apply the threshold, like so:</p><div class="highlight"><pre><span class="k">def</span> <span class="nf">apply_threshold</span><span class="p">(</span><span class="n">buff</span><span class="p">,</span><span class="n">threshold</span><span class="p">,</span> <span class="n">margin</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span><br />    <span class="n">s1</span> <span class="o">=</span> <span class="n">buff</span><span class="o"> &lt;</span><span class="p"> (</span><span class="n">threshold</span><span class="o"> - </span><span class="n">margin</span><span class="p">)</span><br />    <span class="n">s2</span> <span class="o">=</span> <span class="n">buff </span><span class="o">&gt;</span><span class="p"> (</span><span class="n">threshold</span><span class="o"> +</span><span class="n"> margin</span><span class="p">)</span><br />    <span class="n">buff</span><span class="p">[:]</span> <span class="o">=</span> <span class="mi">255</span><br />    <span class="n">buff</span><span class="p">[</span><span class="n">s1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><br />    <span class="k">if</span> <span class="n">margin</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span><br />        <span class="n">buff</span><span class="p">[</span><span class="n">s2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><br />    <span class="k">return</span> <span class="n">buff</span><br /></pre></div> <p>(With this threshold function we can also generate membrane style metaballs, but more on that later.)</p><h2 id="first-go-pythagoras">First go: Pythagoras</h2><p>My first go at this was just a brute force by using Pythagoras to calculate the euclidean distance.</p><div class="highlight"><pre><span class="k">def</span> <span class="nf">dist_sqrt</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span><span class="n">p2</span><span class="p">):</span><br />    <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">p1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">p2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">p1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">p2</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><br /></pre></div> <p>The main loop is then just:</p><div class="highlight"><pre><span class="n">images</span> <span class="o">=</span> <span class="p">[]</span><br /><span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n"> FRAMES</span><span class="p">):</span><br />    <span class="n">buff</span> <span class="o">=</span> <span class="n">generate_buffer</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">WIDTH</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">)),</span> <span class="n">balls</span><span class="p">)</span><br />    <span class="n">buff</span> <span class="o">=</span> <span class="n">apply_threshold</span><span class="p">(</span><span class="n">buff</span><span class="p">,</span><span class="n"> THRESHOLD</span><span class="p">, </span><span class="n">MARGIN</span><span class="p">)</span><br />    <span class="n">im</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">fromarray</span><span class="p">(</span><span class="n">buff</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="s">"RGB"</span><span class="p">)</span><br />    <span class="n">images</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">im</span><span class="p">)</span><br />    <span class="n">update_balls</span><span class="p">(</span><span class="n">balls</span><span class="p">)</span><br /></pre></div> <p>Where update_balls is simply a updating the position of the metaballs given their velocity — bouncing on the “walls” of our simulation, but, importantly not other balls.</p><p>And lo and behold there were metaballs.</p><p></p><div class="separator" style="clear: both; text-align: center;"><a href="https://lh3.googleusercontent.com/-bH2ZZtFDB0Q/YYg0nBBJ4dI/AAAAAAADxEU/hMMZV3BgLUwutW_y7apecvySKHpqUum0ACLcBGAsYHQ/out_5.gif" style="margin-left: 1em; margin-right: 1em;"><img data-original-height="128" data-original-width="128" src="https://lh3.googleusercontent.com/-bH2ZZtFDB0Q/YYg0nBBJ4dI/AAAAAAADxEU/hMMZV3BgLUwutW_y7apecvySKHpqUum0ACLcBGAsYHQ/s16000/out_5.gif" /></a></div><br /><p></p><p></p><p><insert early="" gif=""></insert></p><p>However, as expected, this was rather slow. 100 frames of 128 by 128 clocking in at 46.5s on my macbook air from 2013. </p><div class="highlight"><pre>46.5 s ± 0 ns per loop (mean ± std. dev. of 1 run, 1 loop each)<br /></pre></div> <p>(For fun I ran the same code using Juno on my phone, and runtime went down to about 17s!)</p><p>As you might have guessed the costly computation is the distance function, so I went about experimenting.</p><h2 id="take-two-numpylinalgnorm" style="text-align: left;">Take two: numpy.linalg.norm</h2><p>By naively replacing the distance function from with the equivalent linear algebra norm, we get:</p><div class="highlight"><pre><span class="k">def</span> <span class="nf">dist_linalg</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span><span class="n">p2</span><span class="p">):</span><br />    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">p1</span> <span class="o">-</span> <span class="n">p2</span><span class="p">)</span><br /></pre></div> <p>This led to the same metaballs, but, alas, a higher runtime of 2min 47s!</p><h2 id="take-three" style="text-align: left;">Take three: precalculations<br /></h2><p>Next attempt to investigate precalculation of the computationally costly square root function needed in my first approach.</p><div class="highlight"><pre><span class="n">sqrt_precalc</span> <span class="o">=</span> <span class="p">{}</span><br /><br /><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">, </span><span class="n">WIDTH </span><span class="o">** </span><span class="mi">2 </span><span class="o">+ </span><span class="n">HEIGHT </span><span class="o">** </span><span class="mi">2</span><span class="p">):</span>    <br />    <span class="n">sqrt_precalc</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><br /><br /><span class="k">def</span> <span class="nf">dist_precalc</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span><span class="n">p2</span><span class="p">):</span><br />    <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">p1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o"> - </span><span class="n">p2</span><span class="p">[</span><span class="mi">0</span><span class="p">]) </span><span class="o">** </span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">p1</span><span class="p">[</span><span class="mi">1</span><span class="p">] </span><span class="o">- </span><span class="n">p2</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o"> ** </span><span class="mi">2</span><br />    <span class="k">return</span> <span class="n">sqrt_precalc</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span><br /></pre></div> <p>This did shave off <i>some</i> seconds, and runtime went down to 42s.</p><h2 id="final-approach" style="text-align: left;">Yet another approach: moar precalc!<br /></h2><p>I left it at that, thinking that the future of this would be to look into cheaper distance approximations to cut away parts of the buffer where no metaball could show up, but in my sleep another solution appeared… I was thinking that one could go further with the precalculations and precalculate “fields” of influence for each ball, or “radius”, and use proper linear algebra to get rid of some for loops.</p><div class="highlight"><pre><span class="k">def</span> <span class="nf">precalculate_field</span><span class="p">(</span><span class="n">ball</span><span class="p">,</span> <span class="n">dim</span><span class="p">):</span>    <br />    <span class="n">buff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">dim</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span><br />    <span class="n">ball</span> <span class="o">=</span> <span class="n">Ball</span><span class="p">([</span><span class="n">WIDTH</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">],</span><span class="n">ball</span><span class="o">.</span><span class="n">rad</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]))</span><br />    <span class="k">return</span> <span class="n">generate_buffer_raw</span><span class="p">(</span><span class="n">buff</span><span class="p">,</span> <span class="p">[</span><span class="n">ball</span><span class="p">])</span><br /><br /><span class="n">fields</span> <span class="o">=</span> <span class="p">{}</span><br /><span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">balls</span><span class="p">:</span><br />    <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">rad</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">fields</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span><br />        <span class="n">fields</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">rad</span><span class="p">)]</span> <span class="o">=</span> <span class="n">precalculate_field</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">WIDTH</span><span class="p">,</span> <span class="n">HEIGHT</span><span class="p">]))</span><br /></pre></div> <p>As you can see, to accommodate all possible positions of the balls I generate a field of influence that is 4 times larger than the output buffer.</p><p>Then I updated the generate buffer function to look like this:</p><div class="highlight"><pre><span class="k">def</span> <span class="nf">generate_buffer_precalc</span><span class="p">(</span><span class="n">buff</span><span class="p">,</span> <span class="n">balls</span><span class="p">):</span><br />    <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">balls</span><span class="p">:</span><br />        <span class="n">x1</span> <span class="o">=</span> <span class="n">WIDTH</span> <span class="o">-</span> <span class="nb">int</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><br />        <span class="n">y1</span> <span class="o">=</span> <span class="n">HEIGHT</span> <span class="o">-</span> <span class="nb">int</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><br />        <span class="n">field</span> <span class="o">=</span> <span class="n">fields</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">rad</span><span class="p">)]</span><br />        <span class="n">window</span> <span class="o">=</span> <span class="n">field</span><span class="p">[</span><span class="n">x1</span><span class="p">:</span><span class="n">x1</span><span class="o">+</span><span class="n">WIDTH</span><span class="p">,</span><span class="n">y1</span><span class="p">:</span><span class="n">y1</span><span class="o">+</span><span class="n">HEIGHT</span><span class="p">]</span><br />        <span class="n">buff</span> <span class="o">+=</span> <span class="n">window</span><br />    <span class="k">return</span> <span class="n">buff</span><br /></pre></div> <p>The main trick here is to move the field in place so that it covers the buffer based on where the ball in question is -- a window into it, if you want. The only for loop now is over the balls themselves, and a simple linear algebra addition operation suffices to generate the resulting buffer of accumulated influence.</p><p>And lo and behold it was fast! A thousand fold increase over the best approach so far! </p><div class="highlight"><pre>40 ms ± 687 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)<br /></pre></div> <p>Admittedly it consumes more memory, but hey, memory is cheap, time is money.&nbsp;</p><p></p><div class="separator" style="clear: both; text-align: center;"><a href="https://lh3.googleusercontent.com/-_OrqY4hIsvQ/YYgzfBaLcuI/AAAAAAADxEE/2cuihG7ZR3gSrCw5QI4_O4lfjFiaruIkACLcBGAsYHQ/out_512x512_5681315.gif" style="margin-left: 1em; margin-right: 1em;"><img data-original-height="512" data-original-width="512" src="https://lh3.googleusercontent.com/-_OrqY4hIsvQ/YYgzfBaLcuI/AAAAAAADxEE/2cuihG7ZR3gSrCw5QI4_O4lfjFiaruIkACLcBGAsYHQ/s16000/out_512x512_5681315.gif" /></a></div>Some caveats:<p></p><ol style="text-align: left;"><li>It is <i>slightly </i>less precise since it doesn't do decimal places. (Yet!) (You still get good-enough-looking metaballs, methinks.)</li><li>The precalulculation of the "fields" are not taken into account when reporting the run-time, but that is surprisingly fast -- and only done once per "radius" of metaball...<br /></li></ol><p>More importantly, like this I can implement a real time version of this at some point using, let’s say pygame.</p><p></p><p></p><p>Ah, yes, I promised membranes, here’s a gif:</p><p></p><div class="separator" style="clear: both; text-align: center;"><a href="https://lh3.googleusercontent.com/-4sNaFfAPlSE/YYg0GRZEVPI/AAAAAAADxEM/xH6JjRsbhuQT7mK4aP6OAXWDap62couXgCLcBGAsYHQ/out_128x128_5680169.gif" style="margin-left: 1em; margin-right: 1em;"><img data-original-height="128" data-original-width="128" src="https://lh3.googleusercontent.com/-4sNaFfAPlSE/YYg0GRZEVPI/AAAAAAADxEM/xH6JjRsbhuQT7mK4aP6OAXWDap62couXgCLcBGAsYHQ/s16000/out_128x128_5680169.gif" /></a></div><p></p>