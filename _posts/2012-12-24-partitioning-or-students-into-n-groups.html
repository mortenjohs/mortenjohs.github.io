---
layout: post
title: Partitioning - or, students into n groups - in Ruby
date: '2012-12-24T17:14:00.001+01:00'
author: Morten
tags:
- Programming
- hack
- source code
- algorithm
- stats
- Ruby
modified_time: '2014-12-10T13:47:17.490+01:00'
blogger_id: tag:blogger.com,1999:blog-6967032375013519080.post-3663934906635297913
blogger_orig_url: https://m635j520.blogspot.com/2012/12/partitioning-or-students-into-n-groups.html
---

<span style="font-family: inherit;">A while back a friend of mine asked if I could automate the creation of groups in a class of students - to maximize the variation within each group, but minimize the difference between them. This sounded like an interesting problem, so I set about to solve it in my own naive experimental Monte Carlo (inspired) way - without looking into ways this has been solved (surely elegantly) before. The result was this little Ruby script:</span><br /><div class="gistLoad" data-id="4369631" id="gist-4369631">Loading... </div><span style="font-family: inherit;">First I just require some code I have previously written. (I guess I really should make them into gems or something instead of copying code around...) </span><span style="font-family: Courier New, Courier, monospace;">names.rb</span><span style="font-family: inherit;">&nbsp;tries to guess sex from a person's name and/or title, and </span><span style="font-family: Courier New, Courier, monospace;">countries.rb</span><span style="font-family: inherit;">&nbsp;maps countries to continents, regions etc with some fuzzy matching of names. (I'm looking at you Democratic Republic of Kongo,&nbsp;<a href="http://www.telegraph.co.uk/sport/olympics/news/9428303/North-Korea-flag-mix-up-players-may-have-felt-under-pressure-to-protest.html" target="_blank">Koreas</a>&nbsp;etc.) Easy-peasy.</span><br /><span style="font-family: inherit;"><br /></span><span style="font-family: inherit;">Then I set some standard variables. (Maybe I'll make this dynamic in the future, why not?) The most interesting entry here is the </span><span style="font-family: Courier New, Courier, monospace;">classifiers</span><span style="font-family: inherit;">&nbsp;hash. This maps the columns we want to use later on to maximize the difference of to their respective weights. (This should of course be updated to match whatever is in the input file...) Another semi-useful parameter is </span><span style="font-family: Courier New, Courier, monospace;">number_of_runs</span><span style="font-family: inherit;">. This is the number of simulations the partitioner will perform before keeping the best partitioning. And of course </span><span style="font-family: Courier New, Courier, monospace;">number_of_groups</span><span style="font-family: inherit;">&nbsp;- the number of groups that the students will be split over.</span><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://www.flickr.com/photos/mortenjohs/8234179251/" style="clear: right; float: right; margin-bottom: 1em; margin-left: 1em;" title="Høst i Tete D'Or #1 by mortenjohs, on Flickr"><img alt="Høst i Tete D'Or #1" src="http://farm9.staticflickr.com/8341/8234179251_454eea6404.jpg" height="500" width="332" /></a></div><span style="font-family: inherit;"><br /></span><span style="font-family: Courier New, Courier, monospace;">count</span><span style="font-family: inherit;">&nbsp;is just a variant of my count function already covered here in the blog (<a href="http://m635j520.blogspot.com/2012/12/un-deux-tscha-tscha-or-counting-in-ruby.html" target="_blank">link</a>).</span><br /><span style="font-family: inherit;"><br /></span><span style="font-family: inherit;">I slurp up the list of participants as an array of hashes, from the file name specified above, converting the headers as specified in the </span><span style="font-family: Courier New, Courier, monospace;">variable_names_map</span><span style="font-family: inherit;">&nbsp;hash and generating some standard variables in the process - unless they are already present.</span><br /><span style="font-family: inherit;"><br /></span><span style="font-family: inherit;">The important function in my naive approach is the </span><span style="font-family: Courier New, Courier, monospace;">scoring_function</span><span style="font-family: inherit;">. This basically looks at the extremes one variable at the time. That is, it checks to see if any value (or category) of a variable is over or underrepresented, based on the expected number of elements with this value. </span><span style="font-family: Courier New, Courier, monospace;">samples</span><span style="font-family: inherit;">&nbsp;is a count of number of elements in the group. I iterate over all categories of the variable to find the worst sinner (squared). So if we are looking at sex, it will check male, and then female and generate a score based on the category that is most off from the expected value (The number of participants with that&nbsp;</span>characteristics<span style="font-family: inherit;">&nbsp;divided by number of participants in this group).</span><br /><span style="font-family: inherit;"><br /></span><span style="font-family: inherit;">The </span><span style="font-family: Courier New, Courier, monospace;">penalty_function</span><span style="font-family: inherit;">&nbsp;simply assigns scores to each group in the current partition using the </span><span style="font-family: Courier New, Courier, monospace;">scoring_function</span><span style="font-family: inherit;">&nbsp;per classifier multiplied by the weight of the respective classifiers.</span><br /><span style="font-family: inherit;"><br /></span> <span style="font-family: inherit;">The main loop of the program runs the simulations </span><span style="font-family: Courier New, Courier, monospace;">number_of_runs</span><span style="font-family: inherit;">&nbsp;times. <strike>I clone the participants list and sample from that one so that I can delete participants as I add them to the partitions as I generete them. (Maybe this step is unecessary if Ruby's sample function doesn't loop before all the elements have been exhausted...)</strike>&nbsp;<u>Update: I halved the runtime by rather <a href="http://ruby-doc.org/core-1.9.3/Array.html#method-i-sample" target="_blank">sampling</a> once - a list of the same length as the original list and popping elements from that sampled list.</u> The way I then instansiatiate the empty </span><span style="font-family: Courier New, Courier, monospace;">partitions</span><span style="font-family: inherit;">&nbsp;hash is quite a neat Ruby feature/trick/hack. The default value of a hash (or array) can take blocks as constructors! This means that if you try to pull something non-existant from a hash a new element will be generated based on that block. In this case I generate an empty array when that occurs. (An alternative to that would be to use the </span><span style="font-family: Courier New, Courier, monospace;">||=</span><span style="font-family: inherit;"> operator while adding elements, but that is maybe slightly less elegant...)</span><br /><a href="http://www.flickr.com/photos/mortenjohs/8235244362/" style="clear: left; float: left; margin-bottom: 1em; margin-right: 1em;" title="Høst i Tete D'Or #2 by mortenjohs, on Flickr"><img alt="Høst i Tete D'Or #2" src="http://farm9.staticflickr.com/8207/8235244362_623279e8b8.jpg" height="500" width="332" /></a><span style="font-family: inherit;"><br /></span><span style="font-family: inherit;">After this loop I just write out the best partition.</span><br /><span style="font-family: inherit;"><br /></span><span style="font-family: inherit;">Voila - it takes about <strike>10</strike> 5 seconds on my current computer(s) to generate these groups when number of runs is set to 10000. Not sure if the algorithm is scientifically sound (and it is quite possible rather an overkill), but it seems to actually do the job when assigning a flock of students to groups and was the first thing that sprang to my mind when wanting to create something quickly&nbsp;</span>(It took way longer to write up this blogpost than the code)<span style="font-family: inherit;">&nbsp;and... dirtily...&nbsp;</span><br /><br />The group work got done and groups seemed fairly balanced.<br /><span style="font-family: inherit;"><br /></span><span style="font-family: inherit;"><b>Limitations:&nbsp;</b></span><br /><span style="font-family: inherit;">- Penalizes small groups more heavily than larger groups (if some groups has more participants than other)?</span><br /><span style="font-family: inherit;">- Variables with more categories dominates the score? (There's probably a useful statistical tool to solve this... (</span>Normalisation<span style="font-family: inherit;">?))</span><br /><span style="font-family: inherit;">- Variables have to be categoric (age has to be grouped).</span><br /><span style="font-family: inherit;"><br /></span><span style="font-family: inherit;"><b>Potential future work:</b></span><br /><span style="font-family: inherit;">- Split out the scoring function (and possible the penalty function) as a stand alone library.</span>  <script src="https://cdn.rawgit.com/moski/gist-Blogger/master/public/gistLoader.js" type="text/javascript"></script><br /><span style="font-family: inherit;">- Let the script take arguments for useful parameters (filename, number_of_runs, group_size, variable_names_map, classifiers etc...)</span><br /><span style="font-family: inherit;">- Could it be interesting to look at&nbsp;</span>continuos variables (ie. age) as well as categorical ones?<span style="font-family: inherit;">&nbsp;</span><br /><span style="font-family: inherit;">- Rather than discarding previous partitions one could let new ones evolve from a certain number of branches? (Local minimum problems?)</span><br /><span style="font-family: inherit;"><br /></span><span style="font-family: inherit;">(BTW; God jul!)</span>