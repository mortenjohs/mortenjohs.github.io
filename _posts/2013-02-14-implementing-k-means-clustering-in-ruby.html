---
layout: post
title: Implementing k-means clustering in Ruby
date: '2013-02-14T16:02:00.000+01:00'
author: Morten
tags:
- Programming
- hack
- algorithm
- stats
- Ruby
- visualization
modified_time: '2020-04-25T17:38:45.674+02:00'
thumbnail: https://3.bp.blogspot.com/-3-uOeP2oRGI/URy0qvCx66I/AAAAAAABOGI/t5Ua2cbAWHE/s72-c/clusters-all.png
blogger_id: tag:blogger.com,1999:blog-6967032375013519080.post-528244179387451172
blogger_orig_url: https://m635j520.blogspot.com/2013/02/implementing-k-means-clustering-in-ruby.html
---

<a href="http://www.flickr.com/photos/mortenjohs/8235282056/" style="clear: left; float: left; margin-bottom: 1em; margin-right: 1em;" title="Rundt Ebbesvikvannet by mortenjohs, on Flickr"><img alt="Rundt Ebbesvikvannet" height="375" src="https://farm9.staticflickr.com/8069/8235282056_b0b56f3ae3.jpg" width="500"></a>Inspired by the <a href="http://m635j520.blogspot.fr/2012/12/partitioning-or-students-into-n-groups.html" target="_blank">partitioning problem</a> I set about to implement a well known algorithm, k-means clustering, from memory, for fun! ... and, for science... Interestingly, this is somehow the opposite of the partitioning problem. In the partitioning problem we tried to maximize variation of categorical variables within groups, whereas here we're trying to find groups of elements that are the most "similar" to each other in a n-dimensional continuous space.<br /><br />The main idea of k-means is the following - if you have a bunch of elements and a given number of clusters:<br /><ol><li>Create the initial clusters randomly within the space spanned by the elements (typically (always?) you would pick randomly from your elements).</li><li>Lob all elements into the cluster with the nearest center (using some Euclidean&nbsp;distance metric&nbsp;typically).</li><li>Recenter each cluster on the average of its elements,&nbsp;</li><li>If necessary move the elements to their now nearest clusters.&nbsp;</li><li>Repeat the "re-centering" and moving of elements until we have a "stable" (enough) result.</li></ol>Simple enough, but I don't think I have ever implemented it first hand. (At least not in Ruby.)<br /><br />First I implemented some simple data structures, Points:<br /> <script src="https://gist.github.com/mortenjohs/4452713.js"></script> I use the snazzy method missing as a way to reference named dimensions of points easily, e.g. point.x and point.y (or point.z, point.t, point.w1, point.hausdorff, or point.scary).<br /><br />Clusters are simply: <br /> <script src="https://gist.github.com/mortenjohs/4452718.js"></script> The definition of "moved" was the first design choice I could not remember entirely - is it when a certain number of points "jump" from a cluster to another or when the cluster center moves more than a certain distance? (Most of the time I would assume this boils down to the same.) I went for the latter. The clusters themselves keep track of if they have moved or not.<br /><br />I also implemented a special case of points, 2D points: <br /> <script src="https://gist.github.com/mortenjohs/4452716.js"></script> <br />Last helper method in here is simply to plot these clusters (in 2D), and I use gnuplot like so:<br /> <script src="https://gist.github.com/mortenjohs/4452737.js"></script> <br />The real meat is in the k-means method itself of course:  <br /> <script src="https://gist.github.com/mortenjohs/4452733.js"></script> <br />This takes as parameters the points themselves (as an Enumerable of Points), the number of clusters (k), the delta (defines what is a "move"), and if we want to plot each iteration. (Especially interesting while debugging the algorithm... :-)) No real surprises here, I guess. I chose to delete clusters with no points. I'm not entirely sure if that is what's in the original algorithm. (I guess by now I should duckduckgo it. :-))<br /><br />Then I created a very silly little script that generates 10000 random points in 2D and (tries to) put them into 7 clusters, gnuplot'ing each iteration, to test the algorithm.<br /> <script src="https://gist.github.com/mortenjohs/4452914.js"></script> <br />Voila, the results are in: <br /><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://3.bp.blogspot.com/-3-uOeP2oRGI/URy0qvCx66I/AAAAAAABOGI/t5Ua2cbAWHE/s1600/clusters-all.png" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" height="480" src="https://3.bp.blogspot.com/-3-uOeP2oRGI/URy0qvCx66I/AAAAAAABOGI/t5Ua2cbAWHE/s640/clusters-all.png" width="640"></a></td></tr><tr><td class="tr-caption" style="text-align: center;">montage -geometry "320"x"240" -tile 7x7 outfiles/clusters-7* clusters-all.png</td></tr></tbody></table>Or maybe slightly more interesting, as an animated GIF (with sound?):<br /><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://1.bp.blogspot.com/-yPT9aNry4yo/URy6soWLSGI/AAAAAAABOGY/UkmQdBxY1Fg/s1600/clusters-all.gif" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" src="https://1.bp.blogspot.com/-yPT9aNry4yo/URy6soWLSGI/AAAAAAABOGY/UkmQdBxY1Fg/s1600/clusters-all.gif"></a></td></tr><tr><td class="tr-caption" style="text-align: center;">&nbsp;convert outfiles/clusters-7* clusters-all.gif</td></tr></tbody></table><br /><b>Epiolog</b><br />I guess a variant of this could serve as a solution to the partitioning problem if we just map the categorical variables to the&nbsp;continuous&nbsp;space (using the weights?) and sample one element from each resulting (population/number of groups + 1) cluster (where the cluster size would be locked - <a href="http://en.wikipedia.org/wiki/Lloyd%27s_algorithm" target="_blank">Lloyd's algorithm</a>?) to form groups.<br /><br /><b>Moral</b><br />It is useful to (try to) implement an algorithm you think you know from scratch from time time to see if you really do know all the details in the implementation of it... Especially in new languages.<br /><br />Update: Clone this github if you for any reason would want to play around with this yourself:&nbsp;<a href="https://github.com/mortenjohs/k-means">https://github.com/mortenjohs/k-means</a>...<br />